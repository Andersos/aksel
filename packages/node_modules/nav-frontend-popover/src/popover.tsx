import * as React from 'react';
import * as ReactDOM from 'react-dom';
import * as PT from 'prop-types';
import * as classnames from 'classnames';
import * as _throttle from 'lodash.throttle';

import { EventThrottler, keyCodes, getViewportDimensions, getScrollParents } from 'nav-frontend-js-utils';

import PopoverBase, { PopoverBaseProps, PopoverPosisjonShape, PopoverOrientering } from './popover-base';

const cls = (state, props) => classnames('popover--controlled', {
    'popover--cache': !state.didMount,
    'popover--hidden': state.didMount && !props.apen
});

export interface PopoverProps extends PopoverBaseProps {
    id?: string;
    /**
     * Elementet som popover er forankret til. Dette elementet blir brukt til å posisjonere popover.
     */
    ankerEl?: React.ReactNode;
    /**
     * Callback når popover åpnes.
     */
    onOpen?: () => void;
    /**
     * Callback når popover ber om å lukkes.
     */
    onClose: () => void;
    /**
     * Avstand til anker element i pixler. Default er `16px` (`1rem`) med pil, eller `0` uten pil.
     */
    avstandTilAnker?: number;
}

interface PopoverState {
    didMount: boolean;
    posisjon?: PopoverPosisjonShape;
}

class Popover extends React.Component<PopoverProps, PopoverState> {
    private popoverRef = React.createRef<PopoverBase>();
    private popoverEl;
    private cachedMeasurements;
    private listenToScrollOn;
    private scrollParents: (HTMLElement|Window)[] = [];

    constructor(props) {
        super(props);

        this.state = {
            didMount: false
        };

        window.addEventListener('click', this.handleClick);
        window.addEventListener('keydown', this.handleKeydown);
    }

    componentDidMount() {
        window.setTimeout(() => {
            this.popoverEl = ReactDOM.findDOMNode(this.popoverRef.current);

            this.scrollParents = getScrollParents(this.popoverEl);
            this.scrollParents.forEach((scrollParent) => scrollParent.addEventListener('scroll', this.handleScroll));

            this.cachedMeasurements = this.popoverEl.getBoundingClientRect();

            this.setState({
                didMount: true
            });
        }, 0); // tslint:disable-line:align
    }

    componentWillUnmount() {
        window.removeEventListener('click', this.handleClick);
        window.removeEventListener('keydown', this.handleKeydown);
        this.scrollParents.forEach((scrollParent) => scrollParent.removeEventListener('scroll', this.handleScroll));
    }

    componentWillReceiveProps(nextProps) {
        if (!this.props.ankerEl && nextProps.ankerEl) {
            this.updatePosition(nextProps);
            window.setTimeout(() => this.popoverEl.focus(), 0);
        }
    }

    calculatePosition = (props) => {
        const popoverOffset = this.cachedMeasurements;
        const ankerOffset = props.ankerEl.getBoundingClientRect();
        let avstandTilAnker = (props.utenPil) ? 0 : 12 ;

        if (typeof props.avstandTilAnker !== 'undefined') {
            avstandTilAnker = props.avstandTilAnker;
        }

        let left;
        let top;

        switch (props.orientering) {
            case PopoverOrientering.OverVenstre:
                left = ankerOffset.x + ankerOffset.width - popoverOffset.width;
                top = ankerOffset.y - avstandTilAnker - popoverOffset.height;
                break;
            case PopoverOrientering.OverHøyre:
                left = ankerOffset.x;
                top = ankerOffset.y - avstandTilAnker - popoverOffset.height;
                break;
            case PopoverOrientering.Venstre:
                left = ankerOffset.x - popoverOffset.width - avstandTilAnker;
                top = ankerOffset.y + (ankerOffset.height / 2) - (popoverOffset.height / 2);
                break;
            case PopoverOrientering.Høyre:
                left = ankerOffset.x + ankerOffset.width + avstandTilAnker;
                top = ankerOffset.y + (ankerOffset.height / 2) - (popoverOffset.height / 2);
                break;
            case PopoverOrientering.UnderVenstre:
                left = ankerOffset.x + ankerOffset.width - popoverOffset.width;
                top = ankerOffset.y + ankerOffset.height + avstandTilAnker;
                break;
            case PopoverOrientering.UnderHøyre:
                left = ankerOffset.x;
                top = ankerOffset.y + ankerOffset.height + avstandTilAnker;
                break;
            case PopoverOrientering.Under:
                left = ankerOffset.x + (ankerOffset.width / 2) - (popoverOffset.width / 2);
                top = ankerOffset.y + ankerOffset.height + avstandTilAnker;
                break;
            default: // PopoverOrientering.Over
                left = ankerOffset.x + (ankerOffset.width / 2) - (popoverOffset.width / 2);
                top = ankerOffset.y - avstandTilAnker - popoverOffset.height;
                break;
        }

        const viewPortDimensions = getViewportDimensions();

        left = Math.max(0, left);
        left = Math.min(Math.abs(left), Math.abs(viewPortDimensions.w - popoverOffset.width));

        const pilLeft = ankerOffset.x + (ankerOffset.width / 2) - left - 1;

        return { left, top, pilLeft };
    }

    getPosition = () => {
        if (!this.state.didMount || !this.state.posisjon) return;
        return {
            left: this.state.posisjon!.left,
            top: this.state.posisjon!.top,
            pilLeft: this.state.posisjon!.pilLeft
        };
    }

    updatePosition = (props) => {
        const posisjon = this.calculatePosition(props);
        this.setState({ posisjon });
    }

    handleClick = (e) => {
        if (this.props.ankerEl && !ReactDOM.findDOMNode(this.props.ankerEl).contains(e.target)) {
            this.props.onClose();
        }
    }

    handleKeydown = (e) => {
        if (e.keyCode === keyCodes.esc) this.props.onClose();
    }

    handleResize = () => {
        if (!this.props.ankerEl) return;
        this.updatePosition(this.props);
    }

    handleScroll = () => {
        if (!this.props.ankerEl) return;
        this.updatePosition(this.props);
    }

    render() {
        const { children, ankerEl, onClose, avstandTilAnker, ...rest } = this.props;
        const position = this.getPosition();
        return (
            <EventThrottler event="resize" callback={this.handleResize} delay={100}>
                <PopoverBase
                    apen={ankerEl !== undefined}
                    className={cls(this.state, this.props)}
                    ref={this.popoverRef}
                    posisjon={position}
                    tabIndex={0}
                    {...rest}
                >
                    {children}
                </PopoverBase>
            </EventThrottler>
        );
    }
}

(Popover as React.ComponentClass).propTypes = {
    ankerEl: PT.oneOfType([
        PT.node,
        PT.object
    ]),
    onClose: PT.func.isRequired,
    avstandTilAnker: PT.number
};

export default Popover;
export { default as PopoverBase } from './popover-base';
export { PopoverOrientering } from './popover-base';
