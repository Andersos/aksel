import * as React from 'react';
import * as ReactDOM from 'react-dom';
import * as PT from 'prop-types';
import * as classnames from 'classnames';
import * as _throttle from 'lodash.throttle';

import { EventThrottler, keyCodes, getViewportDimensions } from 'nav-frontend-js-utils';

import PopoverBase, { PopoverBaseProps, PopoverPosisjonShape } from './popover-base';

const cls = (state, props) => classnames({
    'popover--cache': !state.didMount,
    'popover--hidden': state.didMount && !props.apen
});

export interface PopoverProps extends PopoverBaseProps {
    /**
     * Elementet som popover er forankret til. Dette elementet blir brukt til å posisjonere popover.
     */
    ankerEl?: React.ReactNode;
    /**
     * Callback når popover ber om å lukkes
     */
    onClose: () => void;
    /**
     * Avstand til anker element i pixler. Default er `16px` (`1rem`) med pil, eller `0` uten pil.
     */
    avstandTilAnker?: number;
    /**
     * CSS selector til alternativ scroll-konteiner. Default er `window`-objektet, men dette kan 
     * overstyres hvis komponenten skal lytte til scroll-eventen på et annet element. Hvis selektoren
     * matcher flere elementer, vil første matchende element brukes.
     */
    scrollContainerSelector?: string;
}

interface PopoverState {
    didMount: boolean;
    posisjon?: PopoverPosisjonShape;
}

class Popover extends React.Component<PopoverProps, PopoverState> {
    private popoverRef = React.createRef<PopoverBase>();
    private popoverEl;
    private cachedMeasurements;
    private listenToScrollOn;

    constructor(props) {
        super(props);

        this.state = {
            didMount: false
        };

        window.addEventListener('click', this.handleClick);
        window.addEventListener('keydown', this.handleKeydown);
    }

    componentDidMount() {
        this.listenToScrollOn = (this.props.scrollContainerSelector)
            ? document.querySelectorAll(this.props.scrollContainerSelector)[0]
            : window;
        this.listenToScrollOn = this.listenToScrollOn || window;

        window.setTimeout(() => {
            this.popoverEl = ReactDOM.findDOMNode(this.popoverRef.current);
            this.cachedMeasurements = this.popoverEl.getBoundingClientRect();

            this.setState({
                didMount: true
            });
        }, 0);
    }

    componentWillUnmount() {
        window.removeEventListener('click', this.handleClick);
        window.removeEventListener('keydown', this.handleKeydown);
        this.listenToScrollOn.removeEventListener('scroll', this.handleResize);
    }

    componentWillReceiveProps(nextProps) {
        if (!this.props.ankerEl && nextProps.ankerEl) {
            this.updatePosition(nextProps);
            this.listenToScrollOn.addEventListener('scroll', _throttle(this.handleResize, 10));
        } else if (!nextProps.ankerEl) {
            this.listenToScrollOn.removeEventListener('scroll', this.handleResize);
        } else {
            this.updatePosition(nextProps);
        }
    }

    calculatePosition(props) {
        const popoverOffset = this.cachedMeasurements;
        const ankerOffset = props.ankerEl.getBoundingClientRect();
        let avstandTilAnker = (props.utenPil) ? 0 : 12 ;

        if (typeof props.avstandTilAnker !== 'undefined') {
            avstandTilAnker = props.avstandTilAnker;
        }

        let left;
        let top;

        switch (props.orientering) {
            case 'over-venstre':
                left = ankerOffset.x + ankerOffset.width - popoverOffset.width;
                top = ankerOffset.y - avstandTilAnker - popoverOffset.height;
                break;
            case 'over-høyre':
                left = ankerOffset.x;
                top = ankerOffset.y - avstandTilAnker - popoverOffset.height;
                break;
            case 'venstre':
                left = ankerOffset.x - popoverOffset.width - avstandTilAnker;
                top = ankerOffset.y + (ankerOffset.height / 2) - (popoverOffset.height / 2);
                break;
            case 'høyre':
                left = ankerOffset.x + ankerOffset.width + avstandTilAnker;
                top = ankerOffset.y + (ankerOffset.height / 2) - (popoverOffset.height / 2);
                break;
            case 'under-venstre':
                left = ankerOffset.x + ankerOffset.width - popoverOffset.width;
                top = ankerOffset.y + ankerOffset.height + avstandTilAnker;
                break;
            case 'under-høyre':
                left = ankerOffset.x;
                top = ankerOffset.y + ankerOffset.height + avstandTilAnker;
                break;
            case 'under':
                left = ankerOffset.x + (ankerOffset.width / 2) - (popoverOffset.width / 2);
                top = ankerOffset.y + ankerOffset.height + avstandTilAnker;
                break;
            default: // over
                left = ankerOffset.x + (ankerOffset.width / 2) - (popoverOffset.width / 2);
                top = ankerOffset.y - avstandTilAnker - popoverOffset.height;
                break;
        }

        const viewPortDimensions = getViewportDimensions();

        left = Math.max(0, left);
        left = Math.min(left, viewPortDimensions.w - popoverOffset.width);

        // Adjust arrow position

        const pilLeft = ankerOffset.x + (ankerOffset.width / 2) - left - 1;

        return { left, top, pilLeft };
    }

    getPosisjon = () => {
        if (!this.state.didMount || !this.state.posisjon) return;
        return {
            left: this.state.posisjon!.left,
            top: this.state.posisjon!.top,
            pilLeft: this.state.posisjon!.pilLeft
        };
    }

    updatePosition = (props) => {
        const posisjon = this.calculatePosition(props);
        this.setState({posisjon});
    }

    handleClick = (e) => {
        if (this.props.ankerEl && !ReactDOM.findDOMNode(this.props.ankerEl).contains(e.target)) {
            this.props.onClose();
        }
    }

    handleKeydown = (e) => {
        if (e.keyCode === keyCodes.esc) this.props.onClose();
    }

    handleResize = () => {
        if (!this.props.ankerEl) return;
        this.updatePosition(this.props);
    }

    render() {
        const { children, ankerEl, onClose, avstandTilAnker, scrollContainerSelector, ...rest } = this.props;
        const posisjon = this.getPosisjon();
        return (
            <EventThrottler event="resize" callback={this.handleResize} delay={100}>
                <PopoverBase
                    apen={ankerEl !== undefined}
                    className={cls(this.state, this.props)}
                    ref={this.popoverRef}
                    posisjon={posisjon}
                    {...rest}
                >
                    {children}
                </PopoverBase>
            </EventThrottler>
        );
    }
}

(Popover as React.ComponentClass).propTypes = {
    ankerEl: PT.oneOfType([
        PT.node,
        PT.object
    ]),
    onClose: PT.func.isRequired,
    avstandTilAnker: PT.number,
    scrollContainerSelector: PT.string
};

export default Popover;
export { default as PopoverBase } from './popover-base';
export { PopoverOrientering } from './popover-base';
