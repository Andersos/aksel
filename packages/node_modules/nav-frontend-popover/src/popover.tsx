import * as React from 'react';
import * as ReactDOM from 'react-dom';
import * as PT from 'prop-types';
import * as classnames from 'classnames';

import { EventThrottler, keyCodes } from 'nav-frontend-js-utils';

import PopoverBase, { PopoverBaseProps, PopoverPosisjonShape } from './popover-base';

const cls = (state, props) => classnames({
    'popover--cache': !state.didMount,
    'popover--hidden': state.didMount && !props.apen
});

export interface PopoverProps extends PopoverBaseProps {
    /**
     * Elementet som popover er forankret til. Dette elementet blir brukt til å posisjonere popover.
     */
    ankerEl?: React.ReactNode;
    /**
     * Callback når popover ber om å lukkes
     */
    onClose: () => void;
    /**
     * Avstand til anker element i pixler. Default er `16px` (`1rem`) med pil, eller `0` uten pil.
     */
    avstandTilAnker?: number;
}

interface PopoverState {
    didMount: boolean;
    posisjon?: PopoverPosisjonShape;
}

class Popover extends React.Component<PopoverProps, PopoverState> {
    private popoverRef = React.createRef<PopoverBase>();
    private popoverEl;
    private cachedMeasurements;

    static defaultProps: Partial<PopoverProps> = {
        orientering: 'under'
    };

    constructor(props){
        super(props);

        this.state = {
            didMount: false
        };

        window.addEventListener('click', this.handleClick);
        window.addEventListener('keydown', this.handleKeydown);
    }

    componentDidMount(){
        this.popoverEl = ReactDOM.findDOMNode(this.popoverRef.current);
        this.cachedMeasurements = this.popoverEl.getBoundingClientRect();

        this.setState({
            didMount: true
        });
    }

    componentWillUnmount(){
        window.removeEventListener('click', this.handleClick);
        window.removeEventListener('keydown', this.handleKeydown);
    }

    componentWillReceiveProps(nextProps){
        if (!this.props.apen && nextProps.apen && nextProps.ankerEl) {
            this.updatePosition(nextProps.ankerEl);
        }
    }

    calculatePosition(ankerEl) {
        const popoverOffset = (this.props.apen) ? this.popoverEl.getBoundingClientRect() : this.cachedMeasurements ;
        this.cachedMeasurements = popoverOffset;

        const ankerOffset = ankerEl.getBoundingClientRect();

        let avstandTilAnker = (this.props.utenPil) ? 0 : 12 ;

        if (typeof this.props.avstandTilAnker !== 'undefined') {
            avstandTilAnker = this.props.avstandTilAnker;
        }

        switch (this.props.orientering) {
            case 'over':
                return {
                    left: ankerOffset.x + (ankerOffset.width / 2) - (popoverOffset.width / 2),
                    top: ankerOffset.y - avstandTilAnker - popoverOffset.height
                }
            case 'venstre':
                return {
                    left: ankerOffset.x - popoverOffset.width - avstandTilAnker,
                    top: ankerOffset.y + (ankerOffset.height / 2) - (popoverOffset.height / 2)
                }
            case 'høyre':
                return {
                    left: ankerOffset.x + ankerOffset.width + avstandTilAnker,
                    top: ankerOffset.y + (ankerOffset.height / 2) - (popoverOffset.height / 2)
                }
            case 'under-venstre':
                return {
                    left: ankerOffset.x + ankerOffset.width - popoverOffset.width,
                    top: ankerOffset.y + ankerOffset.height + avstandTilAnker
                }
            case 'under-høyre':
                return {
                    left: ankerOffset.x,
                    top: ankerOffset.y + ankerOffset.height + avstandTilAnker
                }
            default:
                return {
                    left: ankerOffset.x + (ankerOffset.width / 2) - (popoverOffset.width / 2),
                    top: ankerOffset.y + ankerOffset.height + avstandTilAnker
                }
        }
    }

    getPosisjon = () => {
        if (!this.state.didMount || !this.state.posisjon) return;
        return {
            left: this.state.posisjon!.left,
            top: this.state.posisjon!.top
        };
    }

    updatePosition = (ankerEl) => {
        const posisjon = this.calculatePosition(ankerEl);
        this.setState({ posisjon });
    }

    handleClick = (e) => {
        if (this.props.apen && !ReactDOM.findDOMNode(this.props.ankerEl).contains(e.target)) {
            this.props.onClose();
        }
    }

    handleKeydown = (e) => {
        if (e.keyCode === keyCodes.esc) this.props.onClose();
    }

    handleResize = () => {
        if (!this.props.apen) return;
        this.updatePosition(this.props.ankerEl);
    }

    render() {
        const { children, ankerEl, onClose, ...rest } = this.props;
        const posisjon = this.getPosisjon();
        return (
            <EventThrottler event="scroll" callback={this.handleResize} delay={0}>
                <EventThrottler event="resize" callback={this.handleResize} delay={100}>
                    <PopoverBase
                        className={cls(this.state, this.props)}
                        ref={this.popoverRef}
                        posisjon={posisjon}
                        onClick={(e) => e.stopPropagation()}
                        {...rest}
                    >
                        {children}
                    </PopoverBase>
                </EventThrottler>
            </EventThrottler>
        );
    }
}

(Popover as React.ComponentClass).propTypes = {
    /**
     * Elementet som popover er forankret til. Dette elementet blir brukt til å posisjonere popover.
     */
    ankerEl: PT.node,
    /**
     * Callback når popover ber om å lukkes
     */
    onClose: PT.func.isRequired,
    /**
     * Avstand til anker element i pixler. Default er `16px` (`1rem`) med pil, eller `0` uten pil.
     */
    avstandTilAnker: PT.number
};

export default Popover;
